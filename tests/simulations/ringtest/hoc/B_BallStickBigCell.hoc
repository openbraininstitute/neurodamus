begintemplate B_BallStickBigCell
public is_art
public init, topol, basic_shape, subsets, geom, biophys, geom_nsec, biophys_inhomo
public synlist, x, y, z, position, connect2target

public soma, dend
public all, den

create soma[1], dend[1]

public gid, CellRef, synHelperList
public nSecAll, nSecSoma, nSecApical, nSecBasal, nSecAxonalOrig, nSecAxonal

objref synlist, synHelperList, segCounts
objref somatic, apical, axonal, basal

proc init() {local i
  apical = new SectionList()
  axonal = new SectionList()
  basal = new SectionList()
  somatic = new SectionList()

  nden = 10
  nseg = 2 // no. of segments per section
  topol(nden)
  for i=0, nden-1 {dend[i].nseg = nseg }
    
  subsets()
  geom()
  indexSections()
  biophys()
  synlist = new List()
  // synapses()
  x = y = z = 0 // only change via position
	
  // require to run neurodamus
  gid = -1
  synHelperList = new List()                                                     
  
}


proc topol() { local i
  create dend[$1]
  connect dend[0](0), soma(1)
  for i=1, $1 - 1 {
    connect dend[i](0), dend[i-1](1)
  }
  basic_shape()
}
proc basic_shape() {
  soma {pt3dclear() pt3dadd(0, 0, 0, 1) pt3dadd(15, 0, 0, 1)}
  dend[0] {pt3dclear() pt3dadd(15, 0, 0, 1) pt3dadd(105, 0, 0, 1)}
}

objref all, den
proc subsets() { local i
  objref all, den
  all = new SectionList()
    forall all.append()
  den = new SectionList()
    for i=0, nden-1 dend[i] { den.append() }

}
proc geom() { local i localobj sref
  soma {  /*area = 500 */ L = diam = 12.6157  }
  access soma
  somatic.append()
  dend[0] {  L = 200  diam = 1  basal.append()}
  for i=1, nden-1 dend[i] { L = 10 diam = 1 basal.append()}
  geom_nsec()

}

proc geom_nsec() { local nSec
  nSec = 0
  forsec all {
      //nseg = int((L/(0.1*lambda_f(100))+.9)/2)*2 + 1
      nSec = nSec + 1
      //print nseg, " ", L
  }
  nSecAll = nSec
  nSec = 0
  forsec somatic { nSec = nSec + 1}
  nSecSoma	= 	nSec
  nSec = 0
  forsec apical { nSec = nSec + 1}
  nSecApical= 	nSec
  nSec = 0
  forsec basal { nSec = nSec + 1}
  nSecBasal	= 	nSec
  nSec = 0
  forsec axonal { nSec = nSec + 1}
  nSecAxonalOrig = nSecAxonal = nSec

  segCounts = new Vector()
  segCounts.resize(nSecAll)
  nSec=0
  forsec all {
      segCounts.x[nSec] = nseg
      nSec = nSec+1
  }
}

//external lambda_f
proc biophys() {
  forsec all {
    Ra = 100
    cm = 1
  }
  soma {
    insert hh
      gnabar_hh = 0.12
      gkbar_hh = 0.036
      gl_hh = 0.0003
      el_hh = -54.3
  }
  forsec den {
    insert pas
      g_pas = 0.001
      e_pas = -65
    insert hh
  }
}
proc biophys_inhomo(){}
proc position() { local i
  soma for i = 0, n3d()-1 {
    pt3dchange(i, $1-x+x3d(i), $2-y+y3d(i), $3-z+z3d(i), diam3d(i))
  }
  x = $1  y = $2  z = $3
}
obfunc connect2target() { localobj nc //$o1 target point process, optional $o2 returned NetCon
  soma nc = new NetCon(&v(1), $o1)
  nc.threshold = 10
  if (numarg() == 2) { $o2 = nc } // for backward compatibility
  return nc
}
objref syn_
proc synapses() {
  /* E0 */   dend[0] syn_ = new ExpSyn(0.8)  synlist.append(syn_)
    syn_.tau = 2
  /* I1 */   dend[0] syn_ = new ExpSyn(0.1)  synlist.append(syn_)
    syn_.tau = 5
    syn_.e = -80
}
func is_art() { return 0 }

proc re_init_rng() {
}

proc clear() {
}

/*!
 * Assign section indices to the section voltage value.  This will be useful later for serializing
 * the sections into an array.  Note, that once the simulation begins, the voltage values will revert to actual data again.
 *
 * @param $o1 Import3d_GUI object
 */
proc indexSections() { local index
    index = 0
    forsec all {
        v(0.0001) = index
        index = index +1
    }
}

endtemplate B_BallStickBigCell
